# Требования и бизнес-цепочки

## Таск-трекер

>>>
1. Таск-трекер должен быть отдельным дашбордом и доступен всем сотрудникам компании UberPopug Inc.
2. Авторизация в таск-трекере должна выполняться через общий сервис авторизации UberPopug Inc (у нас там инновационная система авторизации на основе формы клюва).
>>>

Рассматриваем оба пункта сразу, которые по сути сводятся к @login_required (и далее @has_perm) на каждое действие внутри дашборда. Сначала будем смотреть сессии - если пользователя там нет/expired - переходим на логин.

```
Actor - User
Command - Login to Task Tracker
Data - Username/Beakprint
Event - User.logined
```

>>>
3. В таск-трекере должны быть только задачи. Проектов, скоупов и спринтов нет, потому что они не умещаются в голове попуга.
4. Новые таски может создавать кто угодно (администратор, начальник, разработчик, менеджер и любая другая роль). У задачи должны быть описание, статус (выполнена или нет) и попуг, на которого заассайнена задача.
>>>

Опять оба пункта сразу, создание задачи:

```
Actor - User
Command - Create new task
Data - Task/User.id/User.id (кем и на кого зассайнена задача)
Event - Tasks.created
```

>>>
5. Менеджеры или администраторы должны иметь кнопку «заассайнить задачи», которая возьмёт все открытые задачи и рандомно заассайнит каждую на любого из сотрудников (кроме менеджера и администратора). Не успел закрыть задачу до реассайна — сорян, делай следующую.
a) Ассайнить задачу можно на кого угодно (кроме менеджера и администратора), это может быть любой существующий аккаунт из системы.
b) Ассайнить задачу можно только кнопкой «заассайнить задачи»
c) При нажатии кнопки «заассайнить задачи» все текущие не закрытые задачи должны быть случайным образом перетасованы между каждым аккаунтом в системе
d) Мы не заморачиваемся на ограничение по нажатию на кнопку «заассайнить задачи». Её можно нажимать хоть каждую секунду.
e) На одного сотрудника может выпасть любое количество новых задач, может выпасть ноль, а может и 10.
f) Создать задачу не заасайненую на пользователя нельзя. Т.е. любая задача должна иметь попуга, который ее делает
>>>

```
Actor - Admin/Manager User (role admin/manager)
Command - Reassign tasks
Data - NotCompletedTasks
Event - Tasks.assigned
```

>>>
6. Каждый сотрудник должен иметь возможность видеть в отдельном месте список заассайненных на него задач + отметить задачу выполненной.
>>>

Видеть список - тут без мутаций, ридонли, выполнение задачи:

```
Actor - User
Command - Complete task
Data - Task
Event - Tasks.completed
```

## Аккаунтинг: кто сколько денег заработал

Тут куча ридонли + логин:

```
Actor - User
Command - Login to Accounting
Data - Username/Beakprint
Event - User.logined
```

>>>
В конце дня необходимо:
a) считать сколько денег сотрудник получил за рабочий день
b) отправлять на почту сумму выплаты.
После выплаты баланса (в конце дня) он должен обнуляться, и в аудитлоге всех операций аккаунтинга должно быть отображено, что была выплачена сумма.
>>>

Здесь у нас должны быть четыре таблицы - Users, Tasks, Accounts, Accountlog (user_id, task_id, type). По сути в аккаунте будет содержать только баланс. Его можно было бы считать по логу, с учетом хранения дат операций, но тогда нам пришлось бы постоянно к нему обращаться. Так каждая новая запись в лог будет обновлять баланс, в конце дня он обнуляется в случае успешной оплаты (а она может и не пройти).

Account можно было бы объединить с User, но там же всякие БИКи и кор./счета будут, наверное? У меня будет просто баланс.

Сначала думал объединить оплату и калькуляцию, однако нам для Аналитики не важно - заплатили мы или нет, важны данне, так что рассчитали - послали в очередь, никакие данные не меняем, ничего не списываем:

```
Actor - scheduler at every 00:00
Command - Calculate payments
Data - ?
Event - Accounts.calculated
```

А вот теперь мы уже производим оплату и списываем баланс:

```
Actor - Accounts.calculated
Command - Pay
Data - Accounts/Auditlog
Event - Accounts.received_payment
```

Отправка письма улетает в очередь.

Остальные события будут прилетать из Таск Трекера:

```
Actor - Tasks.created
Command - Write to Accountlog
Data - Accountlog_entry/Account_balance
Event - Accountlog.updated

Actor - Tasks.assigned
Command - Write to Accountlog
Data - Accountlog_entry/Account_balance
Event - Accountlog.updated

Actor - Tasks.completed
Command - Write to Accountlog
Data - Accountlog_entry/Account_balance
Event - Accountlog.updated
```

## Аналитика

>>>
Аналитика — это отдельный дашборд, доступный только админам.
>>>

Здесь у нас полный ридонли, только авторизация:

```
Actor - User
Command - Login to Analytics
Data - Username/Beakprint
Event - User.logined
```

Остальные события будут прилетать из Аккаунтинга, так как нам нужно считать и выводить посуточно по итогам дня заработок топ менеджеров и минуса папугов:

```
Actor - Accounts.calculated
Command - Write to Analyticslog
Data - Analyticslog_entry
Event - Analyticslog.updated
```

Analyticslog (id, date, top_managment_earned, birb_negative_balance_count, most_expensive_task) - после калькуляции аккаунтов мы получаем всю аналитику - аккаунты и лог - отсюда получаем необходимые данные: сколько заработал топ-менеджмент за сегодня и сколько попугов ушло в минус + самая дорогая задача.

## Пермиссии и роли

В первоначальном варианте я планировал хранить пермиссии для каждой системы в самой системе. Тогда мы бы логиниоись через общий сервис аутентификации UberPopug Inc., а уже в каждом сервисе смотрели пермиссии на выполнение какого-то действия в соотв. с ролью. Сейчас были мысли перенести пермиссии в аутентификацию, но тогда нам нужно будет хранить все данные об остальных системах в аутентификации + мы не смогли бы реализовать логику с разделением Таск Трекере. Кажется, все это усложнение и достаточно будет захардкодить простую проверку на роль в каждом сервисе типа:

```
if user.role == 'manager':
...
```

Тогда мы не сможем динамично управлять ролями и пермиссиями, но ведь нам и не нужно в конкретной задаче?