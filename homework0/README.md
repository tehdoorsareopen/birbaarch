# Hometask 0

## Navigation

>>>
* [Вступительное слово](#вступительное-слово)
* [Схема](#схема)
* [Сервисы](#сервисы)
  * [0. Landing Page](#0-landing-page)
  * [1. Task Tracker](#1-task-tracker)
  * [2. Accounting](#2-accounting)
  * [3. Analytics](#3-analytics)
  * [4. Auth](#4-auth)
  * [5. DB Replicator](#5-db-replicator)
  * [6. Notifier](#6-notifier)
* [Заключение](#заключение)
>>>

## Схема

![схема](scheme.png)

## Вступительное слово

К сожалению, опыта построения асинхронной архитектуры не имею, поэтому делал как умею, просто, синхронно,
заложив некоторые возможности масштабирования в будущем и некоторую отказоустойчивость.

## Сервисы

Всего сервисов получилось 7 (0-6), на картинке они пронумерованы, а стрелочки также пронумерованы для удобства описания приницпа работы.

### 0. Landing Page

uberpopug.com
Просто HTML страничка со ссылками на основные сервисы: 

1. Task Tracker - tasktracker.uberpopug.com
2. Accounting - accounting.uberpopug.com
3. Analytics - analytics.uberpopug.com

Ничего тут не происходит, никакой авторизации, никаких передач данных, ничего.

### 1. Task Tracker

Тут у нас логика по созданию, закрытию задач, их реассайну.
На каждое действие вешаем декоратор @auth_required, который проверяет, что пользователь авторизован (в противном случае происходит редирект на сервис аутентификации 4. Auth) и @has_perm - проверяющий, что у пользователя есть пермиссии это действие выполнить (сотрудник не может реассайнить и создавать задачи и т.д.).

Данные:
В БД три таблицы - пользователи (username, role), пермиссии (can_add / can_reassign / ...) и таски (name, status, price, ...).

Взаимодействие с другими сервисами:
1.0: Аутентификация - описано выше (при каждом запросе возвращается пользователь - он либо добавляется, либо обновляет таблицу users)
1.1: Передача данных в репликатор - сюда передаем данные для Аккаунтинга и Аналитики - по двум действиям - ассайну на сотрудника и закрытию задачи (user_id/name, type (assign/close), price)

*Важно!*
Рекомендую сразу перейти к [5. DB Replicator](#5-db-replicator), а потом вернуться - так будет понятнее.

### 2. Accounting

Тут ничего не пишется, только выводятся данные. Они складываются в базу нашим [5. DB Replicator](#5-db-replicator), Аутентификация проходит как и в остальных сервисах. Собственно тут дашборды для вывода данных, логика рассчета и отправки уведомления на почту (2.1). Проблема с моделью пермиссий. Она должна быть отдельной - под нее придется заводить админку и выдавать пермиссии по ролям.

### 3. Analytics

Тут ничего не пишется, только выводятся данные. Они складываются в базу нашим [5. DB Replicator](#5-db-replicator), Аутентификация проходит как и в остальных сервисах. Единственное, что нужно добавить - это таблицу пермиссий, чтобы запрещать просмотр аналитики всем, кроме админов. Не хотелось бы добавлять в Аутентификацию помимо ролей еще и сервисы - пусть только проверяет/регистрирует и возвращает пользователя с ролью, а дальше в каждом сервисе уже свои пермиссии на каждую роль. Единственный минус тут - придется либо хардкодить роль, либо добавлять админку для менеджерения пермиссий.

### 4. Auth

Сервис Аутентификации - содержит логику по аутентификации:
1. Если пользователь есть в системе и он активен (is_active) - отправляет 200 + данные о пользователе в систему из которой пришел запрос (для добавления/обновления)
2. Если пользователя нет - редиректит на регистрацию

Думаю, разумно добавть сюда простеньку админку с суперюзером для менеджмента активности/неактивности пользователей (в случае, например, увольнения). Из админки же будут проставляться роли пользователю.

При регистрации нового пользователя будет отправляться уведомление админу через Notifier (4.4)

Для остальных сервисов будет проводиться одинаковая логика аутентификации в соотв. с написанным выше (4.1, 4.2, 4.3)

Из проблем вижу возможную потерю данных при синках/регистрации при работе с другими сервисами. Однако это решается постоянной аутентификацией сервисов по любому действию - то есть если что-то и пойдет не так, то аутентификация просто не пройдет, а когда она пройдет - то пользователь в сервисе уже будет в актуальном состоянии.

Еще одна проблема - синхронизация ролей между сервисами для выдачи пермиссий. Например, если мы добавим новую роль в сервисе Аутентификации - надо как-то ее будет пошарить на другие сервисы, чтобы на нее можно было навесить или не навешивать пермиссии.

### 5. DB Replicator

Смысл сервиса в том, чтобы иметь основную копию базы, которая будет реплицироваться пока что на два сервиса - Аналитику (5.3) и Аккаунтинг (5.2) (может потом еще добавятся?). По сути это мастер-база, с версионностью и простой логикой - можно сделать на Go с рутинками - раз в n sec клонировать базу в связанные сервисы, если успех - супер, если нет - отправляем нотификацию администраторам системы - отсюда связь с Notifier (5.1) (поэтому он и вынесен в отдельный сервис).

Поскольку для Аналитики и Аккаунтинга нам нужно только читать данные - мы делаем такое разделение. Плюс - если отвалится какая-то база - у нас будут реплики + мы всегда сможем восстановиться с мастер базы и т.д.

### 6. Notifier

Пока реализован как простой отправщик сообщений на почту, получающий по API данные типа (user_mail, message). Однако в дальнейшем можно сделать из него более серьезный сервис, который бы отслеживал логины/логауты пользователей, добавить возможность отправки в мессенджеры/смс и пр.

В целом, в текущей реализации его функционал - это send_mail, который можно просто добавить в необходимые сервисы (Accounting, Auth, DB Replicator). Скорее всего так будет правильнее, потому что в случае чего это все легко выносится в сервис когда будет необходимость, а функция send_mail вместо отправки напрямую будет отправлять в Notifier.

## Заключение

Из проблем мне кажется наиболее неприятной Аутентификация с синхронизацией ролей между сервисами, так как в каждом из 3 основных сервисов нам нужны пользователи. Она решаема без глобальных синхронизаций:
1. В каждом сервисе заводим таблицы БД users, user_roles и user_permissions

```
users:
id, name, role_id, email, ... (по необходимости - если нам нужно подтянуть что-то дополнительное из Аутентификации)

user_roles:
id, name

user_permissions:
id, role_id, permission (can_view, can_add, can_delete, can_change, ... в зависимости от системы)
```

2. При аутентификации любого пользователя в сервис - наполняем эти таблицы
3. Если для какой-то роли нет пермиссий - пишем, что у вас нет доступа
4. Если пермиссия есть - работаем
5. Как только в сервисе Аутентификации заведется новая роль и будут пользователи с такой ролью - при их заходе в сервис - роль появится в базе и на нее можно будет добавить пермиссии

